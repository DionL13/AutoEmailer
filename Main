function onEdit(e) {

  // Editing variables
  const edited = e.range; // Gets the range of the edited cell, declares as const to be unchangeable.
  let ss = edited.getSheet(); // Accessing edited sheet
  const column = edited.getColumn();
  const row = edited.getRow(); 
  const editedCell = edited.getA1Notation(); // Gets cell reference
  let day = ss.getName().bold(); // Gets day of session from sheet name
  let editDetails = [ss, row, day]; // To be passed into email confirmation helper function

  let timeCellRef = "C" + row; //  Stores the corresponding cell for the requested time
  let timeNotesCell = "D" + row; // Stores timing notes cell to check if timing notes are empty
  let confirmedEmailCell = "J" + row; // Confirmation cell to be altered after email
  let opsNotesCell = "K" + row;
  let startTime = "";
  let endTime = "";
  let sessionTime = "";

  let tutorEmail = ""; // Initializes email before for loop to keep as a global variable
  let studentEmail = ""; 
  let cellRef = "G" + row; // G is column for tutor notes, row is request row
  let sessionDetails = "";

  // Ops fixes cells
  let timingOpsCell = "L" + row;
  let studentEmailOpsCell = "M" + row;
  let tutorEmailOpsCell = "N" + row; 
  let sendEmailCell = "O" + row;

  // Initialising logicals for if key data has been obtained for an email to be sent for confirmation. If data has been obtained, variables will update to true. 
  let hasTime = false; 
  let hasStudentEmail = false;
  let hasTutorEmail = false;

  // Remove confirmation status and notes whenever a cell is cleared from the row (not from content or Ops notes)
  if (![5,10,11,12,13,14,15].includes(column) && (ss.getRange(editedCell).isBlank() || ss.getRange(editedCell).getValue() == "⠀") && row > 3){ // row>3 allows for edits to top rows (not requests).  .includes(column) is if the value of column is in the array, returns true

    ss.getRange(confirmedEmailCell).setValue("");
    ss.getRange(opsNotesCell).setValue("");
    ss.getRange(timingOpsCell).setValue("");

    // Resetting background colours for Ops cells
    ss.getRange(timingOpsCell).setBackground('white');
    ss.getRange(studentEmailOpsCell).setBackground('white');
    ss.getRange(tutorEmailOpsCell).setBackground('white');
  } 

  // Ops fixes that require immediate clearing for data privacy
  if (column == 12 && !ss.getRange(editedCell).isBlank() && row >= 3){ // Timing fixes (takes in inputs as time in form 3:00 PM - 5:00 PM)
    sessionTime = ss.getRange(timingOpsCell).getValue(); // Accesses value in timing fixes cell and sets it to the session time in the email
    ss.getRange(editedCell).setBackground('#ACE1AF');
  }
  // Updating Ops fixes section immediately after inputting emails to preserve data privacy
  if (column == 13 && !ss.getRange(editedCell).isBlank() && row >= 3){
    studentEmail = ss.getRange(editedCell).getValue();
    ss.getRange(editedCell).setValue(""); // Immediately removing email
    ss.getRange(editedCell).setBackground('#ACE1AF');
  }
  if (column == 14 && !ss.getRange(editedCell).isBlank() && row >= 3){
    tutorEmail = ss.getRange(editedCell).getValue();
    ss.getRange(editedCell).setValue(""); // Immediately removing email
    ss.getRange(editedCell).setBackground('#ACE1AF');
  }
  

  // TUTOR/STUDENT SEARCHING + EMAILING SECTION

  // Checking if tutor has taken 1:1 after student has filled in their request and time with no timings notes
  if (column == 6) {

    // Ideal time check: second condition is accessing sheet, getting the cell and checking it is NOT empty and that time isn't the invisible character
    if (!ss.getRange(timeCellRef).isBlank() && ss.getRange(timeCellRef).getValue() != "⠀" && ss.getRange(timeNotesCell).isBlank()){
      // Time formatting

      startTime = ss.getRange(timeCellRef).getValue(); // Accesses value in time slot cell

      let startHour = startTime.split(":")[0]; // Splits string at : to check hour
      let startMinutes = startTime.split(":")[1] // Stores minutes and AM/PM of start time
      if (startHour != "12"){ // Calculating end time as 1 hour later than start time by adding 1 to first string element. 
        endTime = String(parseInt(startHour) + 1) + ":" + startMinutes; 
      } else if (startTime.substring(0,2) == "12"){ // If start time is 12, sets end time manually since 12+1 != 1
        endTime = "1:" + startMinutes;
      } 
    }

    editedCellRef = "F" + row; // stores edited cell in tutor column

    if (!ss.getRange(editedCellRef).isBlank()) { // If the edited cell is not left blank (to avoid triggering when a tutor is removed)

      // Only setting time logical for when edited cell isn't blank
      if (startTime != "" && endTime != ""){
        hasTime = true; // If enters this condition, the time is not blank
        sessionTime = startTime + " to " + endTime;

        ss.getRange(timingOpsCell).setFontColor('white');
        ss.getRange(timingOpsCell).setValue(sessionTime);
      }

      // TUTOR EMAIL SECTION
      
      const tutorName = edited.getValue(); 
      let firstName = ""; // Initialising first name of tutor
      let tutorEmailSearchCell = "";

      [firstName, tutorEmail, tutorEmailSearchCell] = findTutorEmail(tutorName); // See Helper Functions script for details

      if (tutorEmail != ""){ // Setting Ops check to true if a tutor email is found
        hasTutorEmail = true;

        // Putting reference search cell in ops section
        ss.getRange(tutorEmailOpsCell).setFontColor('white');
        ss.getRange(tutorEmailOpsCell).setValue(tutorEmailSearchCell);
      }


      // STUDENT EMAIL SECTION

      let studentCell = "A" + row; // Getting preferred student name from 1:1 sheet
      let studentName = ss.getRange(studentCell).getValue(); 
      let studentFirst = ""; // Initialising first name of student
      let studentEmailSearchCell = "";

      [studentFirst, studentEmail, studentEmailSearchCell] = findStudentEmail(studentName);

      if (studentEmail != ""){ // Setting Ops checks to true if student email is found
        hasStudentEmail = true; 

        // Putting reference search cell in ops section
        ss.getRange(studentEmailOpsCell).setFontColor('white');
        ss.getRange(studentEmailOpsCell).setValue(studentEmailSearchCell);
      }


      // Checking if notes section next to inputted tutor name is blank after 10 seconds of orignal edit
      Utilities.sleep(2 * 1000); // Halting (sleeping) script for 10 seconds

      if (ss.getRange(cellRef).isBlank()) { // .isBlank() returns true if tutor notes is empty, then enters if condition 

        // SENDING EMAIL SECTION

        // Finding subject name 
        let subjectCell = "B" + row;
        let subjectName = ss.getRange(subjectCell).getValue().bold(); // Extracts subject name, converts to bold text using .bold() (stores as html bolded)

        sessionDetails = [studentFirst, firstName, subjectName];

        if (studentEmail != "" && tutorEmail != "" && startTime != "" && endTime != ""){ // Required conditions for an email to be sent
          sessionTime = startTime + " to " + endTime; // Combining session time into 1 string
          sendConfirmationEmail(studentEmail,tutorEmail,sessionTime,sessionDetails,editDetails);

          // Clearing reference search cells from ops section if email sends
          ss.getRange(tutorEmailOpsCell).setValue("");
          ss.getRange(studentEmailOpsCell).setValue("");
          ss.getRange(timingOpsCell).setValue("");
          
        } 
        else if (studentEmail == "" || tutorEmail == ""){ // Failsafe: If no emails are found, sets confirmed email cell to Not Confirmed
          let confirmedEmailCell = "J" + row; 
          ss.getRange(confirmedEmailCell).setValue("Not Confirmed");

          // Setting Ops notes message based on which email(s) missing
          if (studentEmail == "" && tutorEmail == ""){
            ss.getRange(opsNotesCell).setValue("Neither email found");
          } 
          else if (tutorEmail == ""){
            ss.getRange(opsNotesCell).setValue("Tutor email not found");
          } 
          else if (studentEmail == ""){
            ss.getRange(opsNotesCell).setValue("Student email not found");
          }
        } 
        else if (startTime == "" && endTime == ""){ // If no time selected 
          if (ss.getRange(timeCellRef).isBlank() || !ss.getRange(timeNotesCell).isBlank() || ss.getRange(timeCellRef).getValue() == "⠀"){ // Timing checks for when time isn't simple

            ss.getRange(confirmedEmailCell).setValue("Not Confirmed");
            if (ss.getRange(timeCellRef).isBlank() || ss.getRange(timeCellRef).getValue() == "⠀"){
              ss.getRange(opsNotesCell).setValue("No time selected");
            } 
            else if (!ss.getRange(timeNotesCell).isBlank()){
              ss.getRange(opsNotesCell).setValue("Timing requirements");
            } 
          }
        }
      } 
      else if (!ss.getRange(cellRef).isBlank()){ // If tutor notes is not empty after waiting, set confirmed email to Not Confirmed
        ss.getRange(confirmedEmailCell).setValue("Not Confirmed"); // Sets value to not confirmed
        ss.getRange(opsNotesCell).setValue("Tutor notes not empty");
      }
    }

    // Checking for Ops fixes (has time (and no timing notes), tutor and student emails). Only triggers if tutor column is edited since this is the only place where has... variables can change
    if (ss.getRange(confirmedEmailCell).getValue() == "Not Confirmed"){ // Only gathers data for unconfirmed requests to be fixed

      // Checking key data to set values to green if they are included
      if (hasStudentEmail == true){
        ss.getRange(studentEmailOpsCell).setBackground('#ACE1AF'); // Sets background colour to green
        ss.getRange(studentEmailOpsCell).setFontColor('#ACE1AF'); // Setting font to new colour to make reference search invisible (safety measure)
      }
      if (hasTutorEmail == true){
        ss.getRange(tutorEmailOpsCell).setBackground('#ACE1AF');
        ss.getRange(hasTutorEmailOpsCell).setFontColor('#ACE1AF'); 
      }
      if (hasTime == true && ss.getRange(cellRef).isBlank()){ // Only says the time is valid if there are no tutor notes as tutor notes may indicate invalid times
        ss.getRange(timingOpsCell).setBackground('#ACE1AF');
        ss.getRange(timingOpsCell).setFontColor('#ACE1AF');
      }
    }
  } 

  /* Dealing with storing previous values for Ops fixes
  // Ops sending emails after three key datapoints are inputted
  if (column == 15 && !ss.getRange(sendEmailCell).isBlank()){ // If cell for sending isn't blank
    if (ss.getRange(timingOpsCell).getBackground() == '#ACE1AF' && ss.getRange(studentEmailOpsCell).getBackground() == '#ACE1AF' && ss.getRange(studentEmailOpsCell).getBackground() == '#ACE1AF'){ // Checking if all necessary data has been provided
      
      // Retrieving student email
      
      // Retrieving tutor email
      

      if (!ss.getRange(timingOpsCell).isBlank()){ // If Ops inputs a time

      }
      sendConfirmationEmail(studentEmail,tutorEmail,sessionTime,sessionDetails,editDetails);
    }
  }
  */
}



/*
Current fixes needed:
- Change font colour in conditional formatting (by custom excel functions) if confirmed email slot changes to Not Confirmed
- Clear ops notes cell and any coloured cells in Ops to Fix if confirmed email cell is changed to "Y" manually
- Clear ops notes and changed confirmed cell to "Y" if send? is "Y"
- Send? detection to check if time, student and tutor email are all satisfied, and send regardless of tutor/student notes
- If send? fails, change confirmation to send anyway fails and the ops notes to why it failed (e.g. timing notes not blank)

Potential Improvements:
- Dropdown in timing notes for half-hour and 2-hour sessions, checking validity based on time frame provided on each day
- If a student doesn't have anyone who's filled the request, send out a slack call to arms message
- If a stundent doesn't have anyone who's filled the request on the day of their session, send ops a progressive email update of how many there are for the day (like the unconfirmed emails)
- Way for users to update code to account for different year's sheets. Search for tutor name and other columns, sheet IDs as a single search at the start of program which updates the auto-emailer code internally.
*/
